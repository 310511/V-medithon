<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Drone Visualization & Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            color: white;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #scene-container {
            width: 100%;
            height: 100%;
        }

        #controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 300px;
        }

        #status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 250px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #4CAF50;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .control-group input[type="number"] {
            width: 60px;
            padding: 5px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            margin-left: 10px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            flex: 1;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        button.danger:hover {
            box-shadow: 0 5px 15px rgba(244, 67, 54, 0.4);
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-label {
            color: #4CAF50;
            font-weight: bold;
        }

        .status-value {
            color: #fff;
        }

        .camera-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .camera-controls button {
            margin: 5px;
            padding: 8px 12px;
            font-size: 12px;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 300px;
        }

        #instructions h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }

        #instructions ul {
            list-style: none;
            font-size: 12px;
        }

        #instructions li {
            margin-bottom: 5px;
            padding-left: 15px;
            position: relative;
        }

        #instructions li:before {
            content: "‚Ä¢";
            color: #4CAF50;
            position: absolute;
            left: 0;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="scene-container"></div>
        
        <div id="controls-panel">
            <h2>üöÅ Drone Controls</h2>
            
            <div class="control-group">
                <label>Altitude (Z)</label>
                <input type="range" id="altitude" min="0" max="50" value="10" step="0.5">
                <input type="number" id="altitude-value" value="10" step="0.5">
            </div>
            
            <div class="control-group">
                <label>Forward/Backward (X)</label>
                <input type="range" id="forward" min="-20" max="20" value="0" step="0.5">
                <input type="number" id="forward-value" value="0" step="0.5">
            </div>
            
            <div class="control-group">
                <label>Left/Right (Y)</label>
                <input type="range" id="lateral" min="-20" max="20" value="0" step="0.5">
                <input type="number" id="lateral-value" value="0" step="0.5">
            </div>
            
            <div class="control-group">
                <label>Rotation (Yaw)</label>
                <input type="range" id="rotation" min="-180" max="180" value="0" step="5">
                <input type="number" id="rotation-value" value="0" step="5">
            </div>
            
            <div class="control-group">
                <label>Pitch</label>
                <input type="range" id="pitch" min="-45" max="45" value="0" step="2">
                <input type="number" id="pitch-value" value="0" step="2">
            </div>
            
            <div class="control-group">
                <label>Roll</label>
                <input type="range" id="roll" min="-45" max="45" value="0" step="2">
                <input type="number" id="roll-value" value="0" step="2">
            </div>
            
            <div class="button-group">
                <button id="reset-btn">Reset</button>
                <button id="auto-fly-btn">Realistic Auto Fly</button>
                <button id="maze-mode-btn">Maze Navigation</button>
                <button id="emergency-btn" class="danger">Emergency Stop</button>
            </div>
        </div>
        
        <div id="status-panel">
            <h2>üìä Status</h2>
            <div class="status-item">
                <span class="status-label">Position:</span>
                <span class="status-value" id="position-status">0, 0, 10</span>
            </div>
            <div class="status-item">
                <span class="status-label">Rotation:</span>
                <span class="status-value" id="rotation-status">0¬∞</span>
            </div>
            <div class="status-item">
                <span class="status-label">Speed:</span>
                <span class="status-value" id="speed-status">0 m/s</span>
            </div>
            <div class="status-item">
                <span class="status-label">Battery:</span>
                <span class="status-value" id="battery-status">85%</span>
            </div>
            <div class="status-item">
                <span class="status-label">Signal:</span>
                <span class="status-value" id="signal-status">Strong</span>
            </div>
            <div class="status-item">
                <span class="status-label">Mode:</span>
                <span class="status-value" id="mode-status">Manual</span>
            </div>
        </div>
        
        <div class="camera-controls">
            <h3>üì∑ Camera</h3>
            <button id="top-view">Top View</button>
            <button id="side-view">Side View</button>
            <button id="follow-view">Follow Drone</button>
                <button id="maze-view">Maze View</button>
            <button id="orbit-view">Orbit View</button>
        </div>
        
        <div id="instructions">
            <h3>üéÆ Controls</h3>
            <ul>
                <li>WASD: Move drone</li>
                <li>Q/E: Rotate drone</li>
                <li>Space: Increase altitude</li>
                <li>Shift: Decrease altitude</li>
                <li>Mouse: Rotate camera</li>
                <li>Scroll: Zoom in/out</li>
            </ul>
        </div>
        
        <div class="loading" id="loading">Loading 3D Scene...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        class DroneSimulation {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.drone = null;
                this.obstacles = [];
                this.mazeWalls = [];
                this.mazePath = [];
                this.autoFlyMode = false;
                this.mazeMode = false;
                this.emergencyStop = false;
                this.currentCameraView = 'orbit';
                this.pathfindingPath = [];
                this.currentPathIndex = 0;
                
                this.dronePosition = { x: 0, y: 0, z: 10 };
                this.droneRotation = { x: 0, y: 0, z: 0 };
                this.droneSpeed = 0;
                this.batteryLevel = 85;
                this.signalStrength = 'Strong';
                
                this.init();
                this.setupEventListeners();
                this.animate();
            }
            
            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
                
                // Camera setup
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(20, 20, 20);
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('scene-container').appendChild(this.renderer.domElement);
                
                // Controls setup
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                this.createLighting();
                this.createGround();
                this.createDrone();
                this.createObstacles();
                this.createEnvironment();
                this.createMaze();
                this.generatePathfindingPath();
                
                // Hide loading
                document.getElementById('loading').style.display = 'none';
            }
            
            createLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);
            }
            
            createGround() {
                // Ground plane
                const groundGeometry = new THREE.PlaneGeometry(100, 100);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x90EE90,
                    transparent: true,
                    opacity: 0.8
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Grid helper
                const gridHelper = new THREE.GridHelper(100, 20, 0x444444, 0x888888);
                gridHelper.position.y = 0.01;
                this.scene.add(gridHelper);
            }
            
            createDrone() {
                this.drone = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(2, 0.5, 2);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                this.drone.add(body);
                
                // Arms
                const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                
                const arm1 = new THREE.Mesh(armGeometry, armMaterial);
                arm1.position.set(1.5, 0, 0);
                arm1.castShadow = true;
                this.drone.add(arm1);
                
                const arm2 = new THREE.Mesh(armGeometry, armMaterial);
                arm2.position.set(-1.5, 0, 0);
                arm2.castShadow = true;
                this.drone.add(arm2);
                
                const arm3 = new THREE.Mesh(armGeometry, armMaterial);
                arm3.position.set(0, 0, 1.5);
                arm3.castShadow = true;
                this.drone.add(arm3);
                
                const arm4 = new THREE.Mesh(armGeometry, armMaterial);
                arm4.position.set(0, 0, -1.5);
                arm4.castShadow = true;
                this.drone.add(arm4);
                
                // Propellers
                const propellerGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.1);
                const propellerMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
                
                for (let i = 0; i < 4; i++) {
                    const propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
                    propeller.position.set(
                        (i % 2 === 0 ? 1.5 : -1.5),
                        0.3,
                        (i < 2 ? 1.5 : -1.5)
                    );
                    propeller.castShadow = true;
                    this.drone.add(propeller);
                }
                
                // Camera
                const cameraGeometry = new THREE.SphereGeometry(0.2);
                const cameraMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const camera = new THREE.Mesh(cameraGeometry, cameraMaterial);
                camera.position.set(0, -0.3, 1);
                this.drone.add(camera);
                
                // LED indicators
                const ledGeometry = new THREE.SphereGeometry(0.05);
                const ledMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                
                const led1 = new THREE.Mesh(ledGeometry, ledMaterial);
                led1.position.set(0.5, 0.3, 0.5);
                this.drone.add(led1);
                
                const led2 = new THREE.Mesh(ledGeometry, ledMaterial);
                led2.position.set(-0.5, 0.3, -0.5);
                this.drone.add(led2);
                
                this.drone.position.set(this.dronePosition.x, this.dronePosition.y, this.dronePosition.z);
                this.scene.add(this.drone);
            }
            
            createObstacles() {
                const obstacleColors = [0xff4444, 0xff8844, 0xffaa44];
                
                for (let i = 0; i < 8; i++) {
                    const geometry = Math.random() > 0.5 ? 
                        new THREE.BoxGeometry(2 + Math.random() * 3, 3 + Math.random() * 5, 2 + Math.random() * 3) :
                        new THREE.CylinderGeometry(1 + Math.random() * 2, 1 + Math.random() * 2, 3 + Math.random() * 5);
                    
                    const material = new THREE.MeshLambertMaterial({ 
                        color: obstacleColors[Math.floor(Math.random() * obstacleColors.length)] 
                    });
                    
                    const obstacle = new THREE.Mesh(geometry, material);
                    obstacle.position.set(
                        (Math.random() - 0.5) * 40,
                        obstacle.geometry.parameters.height / 2,
                        (Math.random() - 0.5) * 40
                    );
                    obstacle.castShadow = true;
                    obstacle.receiveShadow = true;
                    
                    this.obstacles.push(obstacle);
                    this.scene.add(obstacle);
                }
            }
            
            createEnvironment() {
                // Skybox effect
                const skyGeometry = new THREE.SphereGeometry(150, 32, 32);
                const skyMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87CEEB,
                    side: THREE.BackSide
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);
                
                // Clouds
                for (let i = 0; i < 10; i++) {
                    const cloudGeometry = new THREE.SphereGeometry(2 + Math.random() * 3);
                    const cloudMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloud.position.set(
                        (Math.random() - 0.5) * 100,
                        30 + Math.random() * 20,
                        (Math.random() - 0.5) * 100
                    );
                    this.scene.add(cloud);
                }
            }
            
            generateMazeLayout() {
                // Generate a complex maze layout with realistic patterns
                const mazeSize = 25;
                const maze = [];
                
                // Initialize maze with walls
                for (let i = 0; i < mazeSize; i++) {
                    maze[i] = [];
                    for (let j = 0; j < mazeSize; j++) {
                        maze[i][j] = 1; // Start with all walls
                    }
                }
                
                // Create maze using recursive backtracking algorithm
                this.generateMazeRecursive(maze, 1, 1, mazeSize - 2, mazeSize - 2);
                
                // Ensure start and end are clear
                maze[0][0] = 0;
                maze[1][0] = 0;
                maze[0][1] = 0;
                maze[mazeSize-1][mazeSize-1] = 0;
                maze[mazeSize-2][mazeSize-1] = 0;
                maze[mazeSize-1][mazeSize-2] = 0;
                
                // Add some random obstacles for complexity
                for (let i = 0; i < 15; i++) {
                    const x = Math.floor(Math.random() * (mazeSize - 2)) + 1;
                    const y = Math.floor(Math.random() * (mazeSize - 2)) + 1;
                    if (maze[x][y] === 0) {
                        maze[x][y] = 1;
                    }
                }
                
                return maze;
            }
            
            generateMazeRecursive(maze, startX, startY, endX, endY) {
                if (startX >= endX || startY >= endY) return;
                
                // Create horizontal and vertical walls
                const wallX = Math.floor((startX + endX) / 2);
                const wallY = Math.floor((startY + endY) / 2);
                
                // Create passages
                for (let i = startX; i <= endX; i++) {
                    maze[i][wallY] = 0;
                }
                for (let j = startY; j <= endY; j++) {
                    maze[wallX][j] = 0;
                }
                
                // Create random passages
                const passages = [
                    { x: wallX, y: startY + Math.floor(Math.random() * (wallY - startY)) },
                    { x: wallX, y: wallY + Math.floor(Math.random() * (endY - wallY)) },
                    { x: startX + Math.floor(Math.random() * (wallX - startX)), y: wallY },
                    { x: wallX + Math.floor(Math.random() * (endX - wallX)), y: wallY }
                ];
                
                passages.forEach(passage => {
                    if (passage.x >= 0 && passage.x < maze.length && 
                        passage.y >= 0 && passage.y < maze[0].length) {
                        maze[passage.x][passage.y] = 0;
                    }
                });
                
                // Recursively generate sub-mazes
                this.generateMazeRecursive(maze, startX, startY, wallX - 1, wallY - 1);
                this.generateMazeRecursive(maze, wallX + 1, startY, endX, wallY - 1);
                this.generateMazeRecursive(maze, startX, wallY + 1, wallX - 1, endY);
                this.generateMazeRecursive(maze, wallX + 1, wallY + 1, endX, endY);
            }
            
            createMaze() {
                this.mazeLayout = this.generateMazeLayout();
                const wallGeometry = new THREE.BoxGeometry(1, 10, 1);
                const wallMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.9
                });
                
                for (let i = 0; i < this.mazeLayout.length; i++) {
                    for (let j = 0; j < this.mazeLayout[i].length; j++) {
                        if (this.mazeLayout[i][j] === 1) {
                            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                            wall.position.set(
                                (i - this.mazeLayout.length / 2) * 2,
                                5,
                                (j - this.mazeLayout[i].length / 2) * 2
                            );
                            wall.castShadow = true;
                            wall.receiveShadow = true;
                            this.mazeWalls.push(wall);
                            this.scene.add(wall);
                        }
                    }
                }
            }
            
            generatePathfindingPath() {
                // Simple A* pathfinding from start to end
                const start = { x: 0, y: 0 };
                const end = { x: this.mazeLayout.length - 1, y: this.mazeLayout[0].length - 1 };
                
                this.pathfindingPath = this.aStarPathfinding(start, end);
                
                // Visualize path
                this.visualizePath();
            }
            
            aStarPathfinding(start, end) {
                // Simplified A* algorithm for maze navigation
                const openSet = [start];
                const closedSet = new Set();
                const cameFrom = new Map();
                const gScore = new Map();
                const fScore = new Map();
                
                gScore.set(`${start.x},${start.y}`, 0);
                fScore.set(`${start.x},${start.y}`, this.heuristic(start, end));
                
                while (openSet.length > 0) {
                    let current = openSet.reduce((min, node) => 
                        fScore.get(`${node.x},${node.y}`) < fScore.get(`${min.x},${min.y}`) ? node : min
                    );
                    
                    if (current.x === end.x && current.y === end.y) {
                        // Reconstruct path
                        const path = [];
                        while (cameFrom.has(`${current.x},${current.y}`)) {
                            path.unshift(current);
                            current = cameFrom.get(`${current.x},${current.y}`);
                        }
                        path.unshift(start);
                        return path;
                    }
                    
                    openSet.splice(openSet.indexOf(current), 1);
                    closedSet.add(`${current.x},${current.y}`);
                    
                    // Check neighbors
                    const neighbors = [
                        { x: current.x + 1, y: current.y },
                        { x: current.x - 1, y: current.y },
                        { x: current.x, y: current.y + 1 },
                        { x: current.x, y: current.y - 1 }
                    ];
                    
                    for (const neighbor of neighbors) {
                        if (neighbor.x < 0 || neighbor.x >= this.mazeLayout.length ||
                            neighbor.y < 0 || neighbor.y >= this.mazeLayout[0].length ||
                            this.mazeLayout[neighbor.x][neighbor.y] === 1 ||
                            closedSet.has(`${neighbor.x},${neighbor.y}`)) {
                            continue;
                        }
                        
                        const tentativeGScore = gScore.get(`${current.x},${current.y}`) + 1;
                        
                        if (!openSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
                            openSet.push(neighbor);
                        } else if (tentativeGScore >= gScore.get(`${neighbor.x},${neighbor.y}`)) {
                            continue;
                        }
                        
                        cameFrom.set(`${neighbor.x},${neighbor.y}`, current);
                        gScore.set(`${neighbor.x},${neighbor.y}`, tentativeGScore);
                        fScore.set(`${neighbor.x},${neighbor.y}`, tentativeGScore + this.heuristic(neighbor, end));
                    }
                }
                
                return [start]; // No path found
            }
            
            heuristic(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }
            
            visualizePath() {
                // Clear existing path visualization
                this.mazePath.forEach(pathSegment => {
                    this.scene.remove(pathSegment);
                });
                this.mazePath = [];
                
                // Create path visualization
                const pathGeometry = new THREE.SphereGeometry(0.3);
                const pathMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x00FF88,
                    transparent: true,
                    opacity: 0.8
                });
                
                for (let i = 0; i < this.pathfindingPath.length; i++) {
                    const pathPoint = new THREE.Mesh(pathGeometry, pathMaterial);
                    pathPoint.position.set(
                        (this.pathfindingPath[i].x - this.mazeLayout.length / 2) * 2,
                        1.0,
                        (this.pathfindingPath[i].y - this.mazeLayout[0].length / 2) * 2
                    );
                    this.mazePath.push(pathPoint);
                    this.scene.add(pathPoint);
                }
            }
            
            setupEventListeners() {
                // Control sliders
                const controls = ['altitude', 'forward', 'lateral', 'rotation', 'pitch', 'roll'];
                controls.forEach(control => {
                    const slider = document.getElementById(control);
                    const value = document.getElementById(control + '-value');
                    
                    slider.addEventListener('input', (e) => {
                        value.value = e.target.value;
                        this.updateDronePosition();
                    });
                    
                    value.addEventListener('input', (e) => {
                        slider.value = e.target.value;
                        this.updateDronePosition();
                    });
                });
                
                // Buttons
                document.getElementById('reset-btn').addEventListener('click', () => this.resetDrone());
                document.getElementById('auto-fly-btn').addEventListener('click', () => this.toggleAutoFly());
                document.getElementById('maze-mode-btn').addEventListener('click', () => this.toggleMazeMode());
                document.getElementById('emergency-btn').addEventListener('click', () => this.emergencyStop());
                
                // Camera controls
                document.getElementById('top-view').addEventListener('click', () => this.setCameraView('top'));
                document.getElementById('side-view').addEventListener('click', () => this.setCameraView('side'));
                document.getElementById('follow-view').addEventListener('click', () => this.setCameraView('follow'));
                document.getElementById('maze-view').addEventListener('click', () => this.setCameraView('maze'));
                document.getElementById('orbit-view').addEventListener('click', () => this.setCameraView('orbit'));
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));
                
                // Window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            updateDronePosition() {
                if (this.emergencyStop) return;
                
                const altitude = parseFloat(document.getElementById('altitude').value);
                const forward = parseFloat(document.getElementById('forward').value);
                const lateral = parseFloat(document.getElementById('lateral').value);
                const rotation = parseFloat(document.getElementById('rotation').value);
                const pitch = parseFloat(document.getElementById('pitch').value);
                const roll = parseFloat(document.getElementById('roll').value);
                
                this.dronePosition = { x: lateral, y: forward, z: altitude };
                this.droneRotation = { x: pitch, y: rotation, z: roll };
                
                this.drone.position.set(this.dronePosition.x, this.dronePosition.y, this.dronePosition.z);
                this.drone.rotation.set(
                    THREE.MathUtils.degToRad(this.droneRotation.x),
                    THREE.MathUtils.degToRad(this.droneRotation.y),
                    THREE.MathUtils.degToRad(this.droneRotation.z)
                );
                
                this.updateStatus();
            }
            
            updateStatus() {
                document.getElementById('position-status').textContent = 
                    `${this.dronePosition.x.toFixed(1)}, ${this.dronePosition.y.toFixed(1)}, ${this.dronePosition.z.toFixed(1)}`;
                document.getElementById('rotation-status').textContent = 
                    `${this.droneRotation.y.toFixed(0)}¬∞`;
                document.getElementById('speed-status').textContent = 
                    `${this.droneSpeed.toFixed(1)} m/s`;
                document.getElementById('battery-status').textContent = 
                    `${this.batteryLevel}%`;
                document.getElementById('signal-status').textContent = 
                    this.signalStrength;
                document.getElementById('mode-status').textContent = 
                    this.mazeMode ? 'Maze Navigation' : (this.autoFlyMode ? 'Realistic Auto Fly' : 'Manual');
            }
            
            resetDrone() {
                this.emergencyStop = false;
                this.autoFlyMode = false;
                this.mazeMode = false;
                this.currentPathIndex = 0;
                
                const controls = ['altitude', 'forward', 'lateral', 'rotation', 'pitch', 'roll'];
                const resetValues = [10, 0, 0, 0, 0, 0];
                
                controls.forEach((control, index) => {
                    const slider = document.getElementById(control);
                    const value = document.getElementById(control + '-value');
                    slider.value = resetValues[index];
                    value.value = resetValues[index];
                });
                
                this.updateDronePosition();
            }
            
            toggleAutoFly() {
                this.autoFlyMode = !this.autoFlyMode;
                this.mazeMode = false;
                if (this.autoFlyMode) {
                    this.startAutoFly();
                }
            }
            
            toggleMazeMode() {
                this.mazeMode = !this.mazeMode;
                this.autoFlyMode = false;
                if (this.mazeMode) {
                    this.startMazeAutoNavigation();
                }
            }
            
            startAutoFly() {
                if (!this.autoFlyMode) return;
                
                // Create a more complex flight path with waypoints
                const time = Date.now() * 0.001;
                const waypoints = [
                    { x: 0, y: 0, z: 8 },
                    { x: 15, y: 10, z: 6 },
                    { x: -10, y: 20, z: 10 },
                    { x: 5, y: -15, z: 7 },
                    { x: -20, y: -5, z: 9 },
                    { x: 0, y: 0, z: 8 }
                ];
                
                const currentWaypointIndex = Math.floor(time * 0.2) % waypoints.length;
                const nextWaypointIndex = (currentWaypointIndex + 1) % waypoints.length;
                const progress = (time * 0.2) % 1;
                
                const currentWaypoint = waypoints[currentWaypointIndex];
                const nextWaypoint = waypoints[nextWaypointIndex];
                
                // Interpolate between waypoints with realistic movement
                const targetPosition = {
                    x: currentWaypoint.x + (nextWaypoint.x - currentWaypoint.x) * progress,
                    y: currentWaypoint.y + (nextWaypoint.y - currentWaypoint.y) * progress,
                    z: currentWaypoint.z + (nextWaypoint.z - currentWaypoint.z) * progress
                };
                
                // Calculate direction to target
                const direction = {
                    x: targetPosition.x - this.dronePosition.x,
                    y: targetPosition.y - this.dronePosition.y,
                    z: targetPosition.z - this.dronePosition.z
                };
                
                const distance = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
                
                // Realistic drone movement with acceleration and deceleration
                const maxSpeed = 0.4;
                const acceleration = 0.02;
                const decelerationDistance = 3.0;
                
                // Calculate current speed based on distance to target
                let currentSpeed = maxSpeed;
                if (distance < decelerationDistance) {
                    currentSpeed = maxSpeed * (distance / decelerationDistance);
                }
                
                // Add slight hover oscillation for realism
                const hoverOffset = Math.sin(time * 3) * 0.3;
                
                // Calculate new position with realistic movement
                const newPosition = {
                    x: this.dronePosition.x + (direction.x / distance) * currentSpeed,
                    y: this.dronePosition.y + (direction.y / distance) * currentSpeed,
                    z: targetPosition.z + hoverOffset
                };
                
                // Add slight lateral drift for realism
                const driftAmount = 0.05;
                const driftDirection = Math.sin(time * 2);
                newPosition.x += driftDirection * driftAmount;
                
                // Add wind effects for more realism
                const windStrength = 0.03;
                const windDirection = Math.sin(time * 0.5) * windStrength;
                newPosition.x += windDirection;
                newPosition.y += Math.cos(time * 0.7) * windStrength * 0.5;
                
                // Simple obstacle avoidance
                const avoidanceRadius = 3.0;
                let avoidanceVector = { x: 0, y: 0, z: 0 };
                
                // Check obstacles for avoidance
                for (const obstacle of this.obstacles) {
                    const obstacleDistance = Math.sqrt(
                        Math.pow(newPosition.x - obstacle.position.x, 2) +
                        Math.pow(newPosition.y - obstacle.position.y, 2) +
                        Math.pow(newPosition.z - obstacle.position.z, 2)
                    );
                    
                    if (obstacleDistance < avoidanceRadius) {
                        const avoidDirection = {
                            x: newPosition.x - obstacle.position.x,
                            y: newPosition.y - obstacle.position.y,
                            z: newPosition.z - obstacle.position.z
                        };
                        const avoidLength = Math.sqrt(avoidDirection.x * avoidDirection.x + avoidDirection.y * avoidDirection.y + avoidDirection.z * avoidDirection.z);
                        const avoidStrength = (avoidanceRadius - obstacleDistance) / avoidanceRadius;
                        
                        avoidanceVector.x += (avoidDirection.x / avoidLength) * avoidStrength * 0.5;
                        avoidanceVector.y += (avoidDirection.y / avoidLength) * avoidStrength * 0.5;
                        avoidanceVector.z += (avoidDirection.z / avoidLength) * avoidStrength * 0.5;
                    }
                }
                
                // Apply avoidance vector
                newPosition.x += avoidanceVector.x;
                newPosition.y += avoidanceVector.y;
                newPosition.z += avoidanceVector.z;
                
                // Update controls with smooth interpolation
                const smoothingFactor = 0.08;
                const currentLateral = parseFloat(document.getElementById('lateral').value);
                const currentForward = parseFloat(document.getElementById('forward').value);
                const currentAltitude = parseFloat(document.getElementById('altitude').value);
                
                const newLateral = currentLateral + (newPosition.x - currentLateral) * smoothingFactor;
                const newForward = currentForward + (newPosition.y - currentForward) * smoothingFactor;
                const newAltitude = currentAltitude + (newPosition.z - currentAltitude) * smoothingFactor;
                
                document.getElementById('lateral').value = newLateral;
                document.getElementById('lateral-value').value = newLateral;
                document.getElementById('forward').value = newForward;
                document.getElementById('forward-value').value = newForward;
                document.getElementById('altitude').value = newAltitude;
                document.getElementById('altitude-value').value = newAltitude;
                
                // Calculate realistic rotation with smooth turning
                const targetAngle = Math.atan2(direction.x, direction.y) * 180 / Math.PI;
                const currentRotation = parseFloat(document.getElementById('rotation').value);
                
                // Smooth rotation interpolation
                let angleDiff = targetAngle - currentRotation;
                if (angleDiff > 180) angleDiff -= 360;
                if (angleDiff < -180) angleDiff += 360;
                
                const rotationSpeed = 0.03;
                const newRotation = currentRotation + angleDiff * rotationSpeed;
                
                document.getElementById('rotation').value = newRotation;
                document.getElementById('rotation-value').value = newRotation;
                
                // Add slight pitch and roll for realistic flight
                const pitchAmount = Math.sin(time * 1.5) * 2;
                const rollAmount = Math.cos(time * 2) * 1.5;
                
                // Update drone rotation for realistic flight dynamics
                this.droneRotation = { 
                    x: pitchAmount, 
                    y: newRotation, 
                    z: rollAmount 
                };
                
                this.updateDronePosition();
                
                if (this.autoFlyMode) {
                    requestAnimationFrame(() => this.startAutoFly());
                }
            }
            
            startMazeAutoNavigation() {
                if (!this.mazeMode) return;
                
                // Follow the pathfinding path with realistic drone behavior
                if (this.currentPathIndex < this.pathfindingPath.length) {
                    const targetPoint = this.pathfindingPath[this.currentPathIndex];
                    const targetPosition = {
                        x: (targetPoint.x - this.mazeLayout.length / 2) * 2,
                        y: (targetPoint.y - this.mazeLayout[0].length / 2) * 2,
                        z: 3.5 // Lower altitude for maze navigation
                    };
                    
                    // Calculate distance and direction to target
                    const direction = {
                        x: targetPosition.x - this.dronePosition.x,
                        y: targetPosition.y - this.dronePosition.y,
                        z: targetPosition.z - this.dronePosition.z
                    };
                    
                    const distance = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
                    
                    // Realistic drone movement with acceleration and deceleration
                    const maxSpeed = 0.3; // Much slower for very realistic movement
                    const acceleration = 0.02;
                    const decelerationDistance = 3.0; // Start decelerating even earlier
                    
                    // Calculate current speed based on distance to target
                    let currentSpeed = maxSpeed;
                    if (distance < decelerationDistance) {
                        currentSpeed = maxSpeed * (distance / decelerationDistance);
                    }
                    
                    // Add slight hover oscillation for realism
                    const hoverOffset = Math.sin(Date.now() * 0.003) * 0.2; // More pronounced hover
                    
                    // Calculate new position with realistic movement
                    const newPosition = {
                        x: this.dronePosition.x + (direction.x / distance) * currentSpeed,
                        y: this.dronePosition.y + (direction.y / distance) * currentSpeed,
                        z: targetPosition.z + hoverOffset
                    };
                    
                    // Add slight lateral drift for realism
                    const driftAmount = 0.04; // More pronounced drift for realistic flight
                    const driftDirection = Math.sin(Date.now() * 0.002);
                    newPosition.x += driftDirection * driftAmount;
                    
                    // Simple obstacle avoidance for maze walls
                    const avoidanceRadius = 2.5;
                    let avoidanceVector = { x: 0, y: 0, z: 0 };
                    
                    // Check maze walls for avoidance
                    for (const wall of this.mazeWalls) {
                        const wallDistance = Math.sqrt(
                            Math.pow(newPosition.x - wall.position.x, 2) +
                            Math.pow(newPosition.y - wall.position.z, 2)
                        );
                        
                        if (wallDistance < avoidanceRadius) {
                            const avoidDirection = {
                                x: newPosition.x - wall.position.x,
                                y: newPosition.y - wall.position.z,
                                z: 0
                            };
                            const avoidLength = Math.sqrt(avoidDirection.x * avoidDirection.x + avoidDirection.y * avoidDirection.y);
                            const avoidStrength = (avoidanceRadius - wallDistance) / avoidanceRadius;
                            
                            avoidanceVector.x += (avoidDirection.x / avoidLength) * avoidStrength * 0.3;
                            avoidanceVector.y += (avoidDirection.y / avoidLength) * avoidStrength * 0.3;
                        }
                    }
                    
                    // Apply avoidance vector
                    newPosition.x += avoidanceVector.x;
                    newPosition.y += avoidanceVector.y;
                    
                    // Update controls with smooth interpolation
                    const smoothingFactor = 0.05; // Even slower interpolation for very realistic movement
                    const currentLateral = parseFloat(document.getElementById('lateral').value);
                    const currentForward = parseFloat(document.getElementById('forward').value);
                    const currentAltitude = parseFloat(document.getElementById('altitude').value);
                    
                    const newLateral = currentLateral + (newPosition.x - currentLateral) * smoothingFactor;
                    const newForward = currentForward + (newPosition.y - currentForward) * smoothingFactor;
                    const newAltitude = currentAltitude + (newPosition.z - currentAltitude) * smoothingFactor;
                    
                    document.getElementById('lateral').value = newLateral;
                    document.getElementById('lateral-value').value = newLateral;
                    document.getElementById('forward').value = newForward;
                    document.getElementById('forward-value').value = newForward;
                    document.getElementById('altitude').value = newAltitude;
                    document.getElementById('altitude-value').value = newAltitude;
                    
                    // Calculate realistic rotation with smooth turning
                    const targetAngle = Math.atan2(direction.x, direction.y) * 180 / Math.PI;
                    const currentRotation = parseFloat(document.getElementById('rotation').value);
                    
                    // Smooth rotation interpolation
                    let angleDiff = targetAngle - currentRotation;
                    if (angleDiff > 180) angleDiff -= 360;
                    if (angleDiff < -180) angleDiff += 360;
                    
                    const rotationSpeed = 0.02; // Even slower rotation for very realistic turning
                    const newRotation = currentRotation + angleDiff * rotationSpeed;
                    
                    document.getElementById('rotation').value = newRotation;
                    document.getElementById('rotation-value').value = newRotation;
                    
                    // Add slight pitch and roll for realistic flight
                    const pitchAmount = Math.sin(Date.now() * 0.001) * 1.0; // Reduced pitch
                    const rollAmount = Math.cos(Date.now() * 0.0015) * 0.8; // Reduced roll
                    
                    // Update drone rotation for realistic flight dynamics
                    this.droneRotation = { 
                        x: pitchAmount, 
                        y: newRotation, 
                        z: rollAmount 
                    };
                    
                    // Check if reached target with tolerance
                    if (distance < 0.8) {
                        this.currentPathIndex++;
                        // Add a longer pause at waypoints for more realistic behavior
                        setTimeout(() => {
                            if (this.mazeMode) {
                                requestAnimationFrame(() => this.startMazeAutoNavigation());
                            }
                        }, 300);
                        return;
                    }
                } else {
                    // Reached the end - hover in place
                    const hoverOffset = Math.sin(Date.now() * 0.002) * 0.2;
                    const currentAltitude = parseFloat(document.getElementById('altitude').value);
                    const targetAltitude = 3.5 + hoverOffset;
                    
                    document.getElementById('altitude').value = targetAltitude;
                    document.getElementById('altitude-value').value = targetAltitude;
                }
                
                this.updateDronePosition();
                
                if (this.mazeMode) {
                    requestAnimationFrame(() => this.startMazeAutoNavigation());
                }
            }
            
            emergencyStop() {
                this.emergencyStop = true;
                this.autoFlyMode = false;
                this.mazeMode = false;
                this.droneSpeed = 0;
                this.currentCameraView = 'orbit';
                this.updateStatus();
            }
            
            setCameraView(view) {
                this.currentCameraView = view;
                switch(view) {
                    case 'top':
                        this.camera.position.set(0, 50, 0);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'side':
                        this.camera.position.set(30, 0, 30);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'follow':
                        // Dynamic follow camera with smooth movement
                        const followDistance = 12;
                        const followHeight = 6;
                        const followOffset = 8;
                        
                        const targetCameraPos = {
                            x: this.dronePosition.x + followOffset,
                            y: this.dronePosition.y + followHeight,
                            z: this.dronePosition.z + followOffset
                        };
                        
                        // Smooth camera movement
                        const cameraSmoothing = 0.05;
                        this.camera.position.x += (targetCameraPos.x - this.camera.position.x) * cameraSmoothing;
                        this.camera.position.y += (targetCameraPos.y - this.camera.position.y) * cameraSmoothing;
                        this.camera.position.z += (targetCameraPos.z - this.camera.position.z) * cameraSmoothing;
                        
                        this.camera.lookAt(this.dronePosition.x, this.dronePosition.y, this.dronePosition.z);
                        break;
                    case 'maze':
                        this.camera.position.set(0, 20, 0);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'orbit':
                        this.camera.position.set(20, 20, 20);
                        this.controls.target.set(this.dronePosition.x, this.dronePosition.y, this.dronePosition.z);
                        break;
                }
            }
            
            handleKeyPress(event) {
                if (this.emergencyStop) return;
                
                const step = 1;
                const rotationStep = 5;
                
                switch(event.key.toLowerCase()) {
                    case 'w':
                        document.getElementById('forward').value = parseFloat(document.getElementById('forward').value) + step;
                        document.getElementById('forward-value').value = document.getElementById('forward').value;
                        break;
                    case 's':
                        document.getElementById('forward').value = parseFloat(document.getElementById('forward').value) - step;
                        document.getElementById('forward-value').value = document.getElementById('forward').value;
                        break;
                    case 'a':
                        document.getElementById('lateral').value = parseFloat(document.getElementById('lateral').value) - step;
                        document.getElementById('lateral-value').value = document.getElementById('lateral').value;
                        break;
                    case 'd':
                        document.getElementById('lateral').value = parseFloat(document.getElementById('lateral').value) + step;
                        document.getElementById('lateral-value').value = document.getElementById('lateral').value;
                        break;
                    case 'q':
                        document.getElementById('rotation').value = parseFloat(document.getElementById('rotation').value) - rotationStep;
                        document.getElementById('rotation-value').value = document.getElementById('rotation').value;
                        break;
                    case 'e':
                        document.getElementById('rotation').value = parseFloat(document.getElementById('rotation').value) + rotationStep;
                        document.getElementById('rotation-value').value = document.getElementById('rotation').value;
                        break;
                    case ' ':
                        event.preventDefault();
                        document.getElementById('altitude').value = parseFloat(document.getElementById('altitude').value) + step;
                        document.getElementById('altitude-value').value = document.getElementById('altitude').value;
                        break;
                    case 'shift':
                        event.preventDefault();
                        document.getElementById('altitude').value = parseFloat(document.getElementById('altitude').value) - step;
                        document.getElementById('altitude-value').value = document.getElementById('altitude').value;
                        break;
                }
                
                this.updateDronePosition();
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update controls
                this.controls.update();
                
                // Animate propellers with realistic speed variation
                if (this.drone && !this.emergencyStop) {
                    const time = Date.now() * 0.001;
                    const baseSpeed = 0.4;
                    const speedVariation = Math.sin(time * 2) * 0.1;
                    
                    this.drone.children.forEach((child, index) => {
                        if (index >= 4 && index < 8) { // Propellers
                            // Vary propeller speed based on movement
                            const speedMultiplier = this.autoFlyMode ? 1.8 : 1.0;
                            child.rotation.y += (baseSpeed + speedVariation) * speedMultiplier;
                        }
                    });
                    
                    // Add slight drone body oscillation for realism
                    if (this.autoFlyMode) {
                        const bodyOscillation = Math.sin(time * 3) * 0.02;
                        this.drone.rotation.z += bodyOscillation;
                    }
                }
                
                // Update battery and signal
                if (!this.emergencyStop) {
                    this.batteryLevel = Math.max(0, this.batteryLevel - 0.01);
                    if (this.batteryLevel < 20) {
                        this.signalStrength = 'Weak';
                    }
                }
                
                // Update speed based on movement
                const currentPos = this.drone.position;
                this.droneSpeed = Math.sqrt(
                    Math.pow(currentPos.x - this.dronePosition.x, 2) +
                    Math.pow(currentPos.y - this.dronePosition.y, 2) +
                    Math.pow(currentPos.z - this.dronePosition.z, 2)
                ) * 10;
                
                // Update follow camera continuously
                if (this.currentCameraView === 'follow') {
                    const followDistance = 12;
                    const followHeight = 6;
                    const followOffset = 8;
                    
                    const targetCameraPos = {
                        x: this.dronePosition.x + followOffset,
                        y: this.dronePosition.y + followHeight,
                        z: this.dronePosition.z + followOffset
                    };
                    
                    const cameraSmoothing = 0.05;
                    this.camera.position.x += (targetCameraPos.x - this.camera.position.x) * cameraSmoothing;
                    this.camera.position.y += (targetCameraPos.y - this.camera.position.y) * cameraSmoothing;
                    this.camera.position.z += (targetCameraPos.z - this.camera.position.z) * cameraSmoothing;
                    
                    this.camera.lookAt(this.dronePosition.x, this.dronePosition.y, this.dronePosition.z);
                }
                
                this.updateStatus();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize the simulation when the page loads
        window.addEventListener('load', () => {
            new DroneSimulation();
        });
    </script>
</body>
</html>
